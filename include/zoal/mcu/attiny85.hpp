/**
 * Autogenerated file. Do not modify manually.
 */
#ifndef ZOAL_MCU_ATTINY85_HPP
#define ZOAL_MCU_ATTINY85_HPP

#include <stdint.h>
#include <zoal/arch/avr/adc.hpp>
#include <zoal/arch/avr/attiny/cfg.hpp>
#include <zoal/arch/avr/attiny/irq.hpp>
#include <zoal/arch/avr/attiny/metadata.hpp>
#include <zoal/arch/avr/attiny/mux.hpp>
#include <zoal/arch/avr/port.hpp>
#include <zoal/arch/avr/timer16.hpp>
#include <zoal/arch/avr/timer8.hpp>
#include <zoal/arch/enable.hpp>
#include <zoal/arch/power.hpp>
#include <zoal/ct/signature.hpp>
#include <zoal/ct/type_list.hpp>
#include <zoal/gpio/api.hpp>
#include <zoal/gpio/pin.hpp>

namespace zoal { namespace mcu {
    template<uint32_t Frequency>
    class attiny85 {
    public:
        using self_type = attiny85;
        using signature = zoal::ct::signature<'A', 'T', 't', 'i', 'n', 'y', '8', '5'>;

        template<uintptr_t Address, uint8_t PinMask>
        using port = typename ::zoal::arch::avr::port<Address, PinMask>;

        using port_b = port<0x0036, 0x3F>;

        template<uint32_t Address>
        class timer_00_mem_model {
        public:
            using word = uint8_t;

            using OCRxB = zoal::mem::reg<Address + 0x00, zoal::mem::reg_io::read_write, uint8_t, 0xFF>;
            using OCRxA = zoal::mem::reg<Address + 0x01, zoal::mem::reg_io::read_write, uint8_t, 0xFF>;
            using TCCRxA = zoal::mem::reg<Address + 0x02, zoal::mem::reg_io::read_write, uint8_t, 0xFF>;
            using TCNTx = zoal::mem::reg<Address + 0x0A, zoal::mem::reg_io::read_write, uint8_t, 0xFF>;
            using TCCRxB = zoal::mem::reg<Address + 0x0B, zoal::mem::reg_io::read_write, uint8_t, 0xFF>;
            using TIFRx = zoal::mem::reg<Address + 0x10, zoal::mem::reg_io::read_write, uint8_t, 0xFF>;
            using TIMSKx = zoal::mem::reg<Address + 0x11, zoal::mem::reg_io::read_write, uint8_t, 0xFF>;

            static constexpr uint8_t TCCRxA_COMxA = 0xC0;
            static constexpr uint8_t TCCRxA_COMxB = 0x30;
            static constexpr uint8_t TCCRxA_WGMx = 0x03;
            static constexpr uint8_t TCCRxB_FOCxA = 0x80;
            static constexpr uint8_t TCCRxB_FOCxB = 0x40;
            static constexpr uint8_t TCCRxB_WGMx2 = 0x08;
            static constexpr uint8_t TCCRxB_CSx = 0x07;
            static constexpr uint8_t TIFRx_OCFxA = 0x10;
            static constexpr uint8_t TIFRx_OCFxB = 0x08;
            static constexpr uint8_t TIFRx_TOVx = 0x02;
            static constexpr uint8_t TIMSKx_OCIExA = 0x10;
            static constexpr uint8_t TIMSKx_OCIExB = 0x08;
            static constexpr uint8_t TIMSKx_TOIEx = 0x02;
        };

        using timer_00 = ::zoal::arch::avr::timer8<0x0048, 0, false, timer_00_mem_model<0x0048>>;

        template<uint32_t Address>
        class timer_01_mem_model {
        public:
            using word = uint8_t;

            using DTPSx = zoal::mem::reg<Address + 0x00, zoal::mem::reg_io::read_write, uint8_t, 0xFF>;
            using DTxB = zoal::mem::reg<Address + 0x01, zoal::mem::reg_io::read_write, uint8_t, 0xFF>;
            using DTxA = zoal::mem::reg<Address + 0x02, zoal::mem::reg_io::read_write, uint8_t, 0xFF>;
            using OCRxB = zoal::mem::reg<Address + 0x08, zoal::mem::reg_io::read_write, uint8_t, 0xFF>;
            using OCRxC = zoal::mem::reg<Address + 0x0A, zoal::mem::reg_io::read_write, uint8_t, 0xFF>;
            using OCRxA = zoal::mem::reg<Address + 0x0B, zoal::mem::reg_io::read_write, uint8_t, 0xFF>;
            using TCNTx = zoal::mem::reg<Address + 0x0C, zoal::mem::reg_io::read_write, uint8_t, 0xFF>;
            using TCCRx = zoal::mem::reg<Address + 0x0D, zoal::mem::reg_io::read_write, uint8_t, 0xFF>;
            using TIFRx = zoal::mem::reg<Address + 0x15, zoal::mem::reg_io::read_write, uint8_t, 0xFF>;
            using TIMSKx = zoal::mem::reg<Address + 0x16, zoal::mem::reg_io::read_write, uint8_t, 0xFF>;

            static constexpr uint8_t DTPSx_DTPS = 0x03;
            static constexpr uint8_t DTxB_DTVH = 0xF0;
            static constexpr uint8_t DTxB_DTVL = 0x0F;
            static constexpr uint8_t DTxA_DTVH = 0xF0;
            static constexpr uint8_t DTxA_DTVL = 0x0F;
            static constexpr uint8_t TCCRx_CTCx = 0x80;
            static constexpr uint8_t TCCRx_PWMxA = 0x40;
            static constexpr uint8_t TCCRx_COMxA = 0x30;
            static constexpr uint8_t TCCRx_CSx = 0x0F;
            static constexpr uint8_t TIFRx_OCFxA = 0x40;
            static constexpr uint8_t TIFRx_OCFxB = 0x20;
            static constexpr uint8_t TIFRx_TOVx = 0x04;
            static constexpr uint8_t TIMSKx_OCIExA = 0x40;
            static constexpr uint8_t TIMSKx_OCIExB = 0x20;
            static constexpr uint8_t TIMSKx_TOIEx = 0x04;
        };

        using timer_01 = ::zoal::arch::avr::timer8<0x0043, 1, false, timer_01_mem_model<0x0043>>;

        template<uint32_t Address>
        class adc_00_mem_model {
        public:
            using ADCSRBx = zoal::mem::reg<Address + 0x00, zoal::mem::reg_io::read_write, uint8_t, 0xFF>;
            using ADCx = zoal::mem::reg<Address + 0x01, zoal::mem::reg_io::read_write, uint8_t, 0xFF>;
            using ADCSRAx = zoal::mem::reg<Address + 0x03, zoal::mem::reg_io::read_write, uint8_t, 0xFF>;
            using ADMUXx = zoal::mem::reg<Address + 0x04, zoal::mem::reg_io::read_write, uint8_t, 0xFF>;
            using DIDR0x = zoal::mem::reg<Address + 0x11, zoal::mem::reg_io::read_write, uint8_t, 0xFF>;
        };

        using adc_00 = ::zoal::arch::avr::adc<0x0023, 0, adc_00_mem_model<0x0023>>;

        template<class Port, uint8_t Offset>
        using pin = typename ::zoal::gpio::pin<Port, Offset>;

        using pb_00 = pin<port_b, 0>;
        using pb_01 = pin<port_b, 1>;
        using pb_02 = pin<port_b, 2>;
        using pb_03 = pin<port_b, 3>;
        using pb_04 = pin<port_b, 4>;
        using pb_05 = pin<port_b, 5>;

        using ports = ::zoal::ct::type_list<port_b>;
        using api = ::zoal::gpio::api;
        using mux = ::zoal::arch::avr::attiny::mux<self_type>;
        using cfg = ::zoal::arch::avr::attiny::cfg<self_type>;
        using irq = ::zoal::arch::avr::attiny::irq;

        template<class... Module>
        using power = ::zoal::arch::power<Module...>;

        template<class... Module>
        using enable = ::zoal::arch::enable<Module...>;
    };
}}

namespace zoal { namespace metadata {
    using zoal::ct::integral_constant;
    using attiny85_sign = zoal::ct::signature<'A', 'T', 't', 'i', 'n', 'y', '8', '5'>;

    template<>
    struct pin_to_pwm_channel<attiny85_sign, 0x0048, 0x0036, 1, 1> : integral_constant<bool, true> {};

    template<>
    struct pin_to_pwm_channel<attiny85_sign, 0x0048, 0x0036, 0, 0> : integral_constant<bool, true> {};

    template<>
    struct pin_to_pwm_channel<attiny85_sign, 0x0043, 0x0036, 4, 1> : integral_constant<bool, true> {};

    template<>
    struct pin_to_pwm_channel<attiny85_sign, 0x0043, 0x0036, 1, 0> : integral_constant<bool, true> {};

    template<>
    struct pin_to_adc_channel<attiny85_sign, 0x0023, 0x0036, 5> : integral_constant<int, 0> {};

    template<>
    struct pin_to_adc_channel<attiny85_sign, 0x0023, 0x0036, 2> : integral_constant<int, 1> {};

    template<>
    struct pin_to_adc_channel<attiny85_sign, 0x0023, 0x0036, 4> : integral_constant<int, 2> {};
}}

#endif
